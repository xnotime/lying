<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lying</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css" integrity="sha384-7P0NVe9LPDbUCAF+fH2R8Egwz1uqNH83Ns/bfJY0fN2XCDBMUI2S9gGzIOIRBKsA" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/howler@2.2.4/dist/howler.min.js" integrity="sha384-SSf4pKRrGaeWL8bdA89QvGkhZo5WvIVCGwKVzfX7z+9sSaIHtE/AkOLehofI4JVY" crossorigin="anonymous"></script>
    <style>html { margin: 20px; } .ch { text-align: center; } .aa { display: flex; width: fit-content; margin-inline: auto; } .aa h1 { margin: 0; font-size: 65pt; } .sub { font-size: 50pt; } .guesslink { font-size: 30pt; }</style>
</head>
<body>
    <header>
        <h1 class="ch">You're in! The code is <code>{{ code }}</code>.</h1>
    </header>
    <main>
        <article class="aa">
            <h1 id="articlename">
                <a id="readylink">Click to Start</a>
            </h1>
        </article>
        <progress id="progress-1" value="1" style="display: none;"></progress>
        <section>
            <div id="speakers">
            </div>
        </section>
    </main>
    <script type="text/javascript">
    let readylink = document.getElementById('readylink');
    let articlename = document.getElementById('articlename');
    let speakers = document.getElementById('speakers');
    let prog = document.getElementById('progress-1');
    let ask_interval;
    let time_left = 10_000;
    let code = '{{ code }}'; // kinda xss-y but should be fine
    let sound_menu = new Howl({
        loop: true,
        src: ['/static/main_menu.mp3'],
    });
    let sound_beep = new Howl({
        volume: 0.5,
        src: ['/static/beepbeep.mp3'],
    });
    let sound_glitch = new Howl({
        volume: 5.0,
        src: ['/static/shortglitch.mp3'],
    });
    let sound_live = new Howl({
        loop: true,
        src: ['/static/detroit_city_ambient.mp3'],
    });
    sound_menu.play();
    let last_beep_time_left = 11_000;
    readylink.onclick = async () => {
        let status = '@not-started';
        let issued_start = false;
        while (status == '@not-started') {
            let status_resp = await fetch(`/api/${code}/status`);
            status = await status_resp.text();
            if (status == '@not-started' && !issued_start) {
                await fetch(`/api/${code}/start`);
                issued_start = true;
            }
        }
        let article_resp = await fetch(`/api/${code}/chosen/article`);
        let article = await article_resp.text();
        articlename.innerHTML = article;
        prog.style.display = 'inline';
        ask_interval = setInterval(() => {
            if (time_left > 0) {
                prog.value = `${(time_left / 10_000)}`;
                if ((last_beep_time_left - time_left) > 1000) {
                    last_beep_time_left = time_left;
                    sound_beep.play();
                }
                time_left -= 10;
            }
        }, 10);
    };
    let speakers_added = 0;
    let interval_update = null;
    let reveal = false;
    interval_update = setInterval(async () => {
        let status_resp = await fetch(`/api/${code}/status`);
        let status = await status_resp.text();
        if (status == '@live') {
            clearInterval(ask_interval);
            sound_menu.stop();
            sound_glitch.play();
            sound_live.play();
            prog.style.display = 'none';
            let spkrdescs = document.getElementsByClassName('spkrdesc');
            let guesslinks = document.getElementsByClassName('guesslink');
            let speakers_resp = await fetch(`/api/${code}/speakers`);
            let speakers_found = (await speakers_resp.json())['list'];
            let bindings = new Map();
            let max_desc_len = '[no response]'.length;
            for (const spkr of speakers_found) {
                bindings.set(spkr.ne, {
                    spkr,
                    spkrdesc: null,
                });
                if (spkr.desc.length > max_desc_len) {
                    max_desc_len = spkr.desc.length;
                }
            }
            for (const spkrdesc of spkrdescs) {
                let ne = spkrdesc.attributes['data-ne'].nodeValue;
                bindings.get(ne).spkrdesc = spkrdesc;
            }
            let type_interval;
            let idx = 0;
            type_interval = setInterval(() => {
                if (idx > max_desc_len) {
                    clearInterval(type_interval);
                } else {
                    for (const [ne, obj] of bindings) {
                        if (obj.spkr.desc) {
                            obj.spkrdesc.innerText = obj.spkr.desc.substring(0, idx);
                        } else {
                            obj.spkrdesc.innerText = '[no response]'.substring(0, idx);
                        }
                    }
                    idx++;
                }
            }, (sound_glitch.duration() * 1000) / (max_desc_len + 3));
            for (const guesslink of guesslinks) {
                let ne = guesslink.attributes['data-ne'].nodeValue;
                guesslink.style.display = 'inline';
                guesslink.onclick = async () => {
                    let guess_resp = await fetch(`/api/${code}/guess/${ne}`);
                    let color = await guess_resp.text();
                    guesslink.parentElement.style.color = color;
                    guesslink.style.display = 'none';
                };
            }
            while (interval_update == null) {}
            clearInterval(interval_update);
        } else {
            let speakers_resp = await fetch(`/api/${code}/speakers`);
            let speakers_json = await speakers_resp.json();
            let speakers_found = speakers_json['list'];
            if (speakers_found.length > speakers_added) {
                for (const new_speaker of speakers_found.slice(speakers_added)) {
                    let ne = new_speaker.ne;
                    let name = atob(ne);
                    let desc = new_speaker.desc;
                    let new_card = document.createElement('article');
                    new_card.className = 'sub';
                    new_card.innerHTML = `
                        <strong>${name}</strong> says
                        <strong ><span class="spkrdesc" data-ne="${ne}">...</span></strong>
                        <a class="guesslink" data-ne="${ne}" style="float: right; display: none;">Guess them!</a>
                    `;
                    speakers.appendChild(new_card);
                }
                speakers_added = speakers_found.length;
            }
        }
    }, 250);
    </script>
</body>
</html>
